<!DOCTYPE html>
<html lang="en">
<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0, user-scalable=no">
    <title>LEXIMAX</title>
    <style>
        * {
            -webkit-tap-highlight-color: transparent;
            box-sizing: border-box;
            margin: 0;
            padding: 0;
            font-family: Arial, sans-serif;
        }

        body {
            background-color: white;
            display: flex;
            flex-direction: column;
            align-items: center;
            padding: 20px;
            min-height: 100vh;
        }

        .game-wrapper {
            width: 100%;
            max-width: 320px;
            background-color: white;
            display: flex;
            flex-direction: column;
            align-items: center;
            gap: 8px;
            overflow: hidden;
        }

        #leximax-title {
            display: flex;
            gap: 0;
            margin-bottom: 8px;
        }

        .title-block {
            width: 45px;
            height: 45px;
            display: flex;
            justify-content: center;
            align-items: center;
            font-size: 35px;
            font-weight: bold;
            color: white;
        }

        #target-word-container {
            text-align: center;
            margin-bottom: 8px;
        }

        #target-word-label {
            font-size: 22px;
            margin-bottom: 4px;
            font-weight: bold;
            color: #666666;
        }

        #target-word {
            display: flex;
            gap: 1px;
            justify-content: center;
            background-color: white;
            padding: 1px;
            border: 1px solid #004d40;
        }

        .target-letter {
            width: 25px;
            height: 25px;
            background-color: #004d40;
            color: white;
            display: flex;
            justify-content: center;
            align-items: center;
            font-weight: bold;
            font-size: 16px;
            position: relative;
        }

        .target-letter::after {
            content: '';
            position: absolute;
            top: 0;
            left: 0;
            right: 0;
            bottom: 0;
            border: 1px solid rgba(255, 255, 255, 0.1);
            pointer-events: none;
        }

        #game-grid {
            width: 100%;
            aspect-ratio: 8/10;
            background-color: white;
            display: grid;
            grid-template-columns: repeat(8, 1fr);
            grid-template-rows: repeat(10, 1fr);
            gap: 1px;
            border: 1px solid #004d40;
            padding: 1px;
            margin-bottom: 1px;
            position: relative;
            overflow: hidden;
        }

        .grid-cell {
            background-color: #004d40;
            position: relative;
            width: 100%;
            height: 100%;
        }

        .grid-cell::after {
            content: '';
            position: absolute;
            top: 0;
            left: 0;
            right: 0;
            bottom: 0;
            border: 1px solid rgba(255, 255, 255, 0.1);
            pointer-events: none;
        }

        .grid-cell.filled {
            display: flex;
            justify-content: center;
            align-items: center;
            font-weight: bold;
            color: white;
            font-size: 16px;
            transition: transform 0.1s ease-out;
        }

        #mobile-controls {
            width: 100%;
            max-width: 320px;
            display: grid;
            grid-template-columns: repeat(3, 1fr);
            gap: 8px;
            margin-bottom: 16px;
        }

        .mobile-btn {
            aspect-ratio: 1;
            width: calc((320px - 16px) / 3);
            background-color: #003366;
            border: none;
            border-radius: 12px;
            color: white;
            font-size: 45px;
            cursor: pointer;
            display: flex;
            justify-content: center;
            align-items: center;
        }

        #time-display {
            width: 100%;
            display: grid;
            grid-template-columns: 1fr 1fr;
            gap: 8px;
            margin-bottom: 8px;
        }

        #controls {
            display: flex;
            flex-direction: column;
            gap: 8px;
        }

        .time-container {
            padding: 6px;
            text-align: center;
            color: white;
            font-weight: bold;
            font-size: 12px;
            line-height: 1.2;
            border-radius: 2px;
        }

        #timer-container {
            background-color: #004d40;
        }

        #best-time-container {
            background-color: #d32f2f;
        }

        #game-buttons {
            width: 100%;
            display: grid;
            grid-template-columns: 1fr 1fr;
            gap: 8px;
        }

        .game-btn {
            background-color: #003366;
            color: white;
            border: none;
            border-radius: 2px;
            padding: 8px;
            font-weight: bold;
            cursor: pointer;
            text-transform: uppercase;
            font-size: 14px;
        }

        #leaderboard {
            width: 100%;
            max-width: 320px;
            margin-top: 15px;
            border-collapse: collapse;
            background-color: #f0f0f0;
            color: #000000;
            border-radius: 2px;
            overflow: hidden;
        }

        #leaderboard caption {
            background-color: #003366;
            color: white;
            padding: 8px;
            font-weight: bold;
            text-transform: uppercase;
            font-size: 14px;
        }

        #leaderboard th, #leaderboard td {
            padding: 6px 12px;
            text-align: left;
            border-bottom: 1px solid #cccccc;
            font-size: 14px;
        }

        .game-over {
            position: absolute;
            top: 50%;
            left: 50%;
            transform: translate(-50%, -50%);
            background-color: rgba(0, 0, 0, 0.9);
            color: white;
            padding: 20px;
            border-radius: 8px;
            text-align: center;
            z-index: 1000;
        }

        .game-over input {
            margin: 10px 0;
            padding: 5px;
            width: 200px;
        }

        .game-over button {
            background-color: #003366;
            color: white;
            border: none;
            padding: 8px 16px;
            border-radius: 4px;
            cursor: pointer;
            margin-top: 10px;
        }
    </style>
</head>
<body>
    <div class="game-wrapper">
        <div id="leximax-title">
            <div class="title-block" style="background-color: #2196f3;">L</div>
            <div class="title-block" style="background-color: #f44336;">E</div>
            <div class="title-block" style="background-color: #4caf50;">X</div>
            <div class="title-block" style="background-color: #ffc107;">I</div>
            <div class="title-block" style="background-color: #9c27b0;">M</div>
            <div class="title-block" style="background-color: #0066FF;">A</div>
            <div class="title-block" style="background-color: #900C3F;">X</div>
        </div>

        <div id="target-word-container">
            <div id="target-word-label">TARGET WORD:</div>
            <div id="target-word"></div>
        </div>

        <div id="game-grid"></div>

        <div id="controls">
            <div id="mobile-controls">
                <button class="mobile-btn" id="left-btn">◀</button>
                <button class="mobile-btn" id="down-btn">▼</button>
                <button class="mobile-btn" id="right-btn">▶</button>
            </div>

            <div id="game-buttons">
                <button class="game-btn" id="start-btn">START</button>
                <button class="game-btn" id="pause-btn">PAUSE</button>
            </div>

            <div id="time-display">
                <div id="timer-container" class="time-container">
                    Time:<br>00:00
                </div>
                <div id="best-time-container" class="time-container">
                    Best Time:<br>--:--
                </div>
            </div>
        </div>
    </div>

    <table id="leaderboard">
        <caption>LEADERBOARD</caption>
        <thead>
            <tr>
                <th>Rank</th>
                <th>Name</th>
                <th>Time</th>
            </tr>
        </thead>
        <tbody></tbody>
    </table>

    <script type="module">
        // Firebase Imports
        import { initializeApp } from "https://www.gstatic.com/firebasejs/9.17.1/firebase-app.js";
        import { 
            getFirestore, 
            doc, 
            getDoc, 
            collection,
            addDoc,
            query, 
            orderBy, 
            limit, 
            onSnapshot 
        } from "https://www.gstatic.com/firebasejs/9.17.1/firebase-firestore.js";

        // Firebase Configuration
        const firebaseConfig = {
            apiKey: "AIzaSyC7MGy-7Gh5h1zp6KjuDq2_pRekPvCHrM4",
            authDomain: "leximax-96299.firebaseapp.com",
            projectId: "leximax-96299",
            storageBucket: "leximax-96299.appspot.com",
            messagingSenderId: "1067424610925",
            appId: "1:1067424610925:web:f2d344a474e9bad8b8dd64"
        };

        // Initialize Firebase
        const app = initializeApp(firebaseConfig);
        const db = getFirestore(app);

        // Game Variables
        let TARGET_WORD = '';
        let GAME_ID = '';
        const GRID_WIDTH = 8;
        const GRID_HEIGHT = 10;
        const COLORS = ['#2196f3', '#f44336', '#4caf50', '#ffc107', '#9c27b0', '#003366', '#009688'];
        const LETTERS = 'BCDFGHJKLMNPQRSTVWXZ';
        const VOWELS = 'AEIOUY';
        let grid = Array(GRID_HEIGHT).fill().map(() => Array(GRID_WIDTH).fill(null));
        let currentBlock = null;
        let nextBlock = null;
        let gameInterval = null;
        let timerInterval = null;
        let gameTime = 0;
        let isPaused = false;
        let isGameOver = false;
        let isMoving = false;
        let bestTime = localStorage.getItem('bestTime') || null;

        // Fix 1: Add function to initialize target word display before game starts
        async function initializeTargetWord() {
            try {
                const today = new Date().toISOString().split('T')[0];
                const gameId = `Game${today}`;
                console.log("Looking for game:", gameId);
                const gameDoc = await getDoc(doc(db, 'daily_games', gameId));
                if (!gameDoc.exists()) {
                    console.error("No word found for today");
                    return false;
                }
                TARGET_WORD = gameDoc.data().targetWord;
                GAME_ID = gameId;
                console.log("Found word:", TARGET_WORD);

                const targetWordDiv = document.getElementById('target-word');
                targetWordDiv.innerHTML = '';
                for (const letter of TARGET_WORD) {
                    const letterDiv = document.createElement('div');
                    letterDiv.className = 'target-letter';
                    letterDiv.textContent = letter;
                    targetWordDiv.appendChild(letterDiv);
                }
                return true;
            } catch (error) {
                console.error("Error initializing target word:", error);
                return false;
            }
        }

        // Utility Functions
        function formatTime(seconds) {
            const mins = Math.floor(seconds / 60);
            const secs = seconds % 60;
            return `${String(mins).padStart(2, '0')}:${String(secs).padStart(2, '0')}`;
        }

        function updateTimer() {
            if (!isPaused && !isGameOver) {
                gameTime++;
                document.querySelector('#timer-container').innerHTML = `Time:<br>${formatTime(gameTime)}`;
            }
        }
        async function addLeaderboardEntry(name, time) {
            try {
                const entry = {
                    name: String(name),
                    time: Number(time),
                    timestamp: new Date().toISOString()
                };
                await addDoc(collection(db, 'daily_games', GAME_ID, 'leaderboard'), entry);
            } catch (error) {
                console.error("Error adding leaderboard entry:", error);
            }
        }

        function createBlock() {
            const letter = Math.random() < 0.3 ? 
                VOWELS[Math.floor(Math.random() * VOWELS.length)] : 
                LETTERS[Math.floor(Math.random() * LETTERS.length)];
            
            return {
                letter,
                color: COLORS[Math.floor(Math.random() * COLORS.length)],
                x: Math.floor(GRID_WIDTH / 2),
                y: 0
            };
        }

        function checkCollision(x, y) {
            if (x < 0 || x >= GRID_WIDTH || y >= GRID_HEIGHT) return true;
            if (y < 0) return false;
            return grid[y][x] !== null;
        }

        // Fix 2: Improved block movement and display
        function updateGrid() {
            const gameGrid = document.getElementById('game-grid');
            gameGrid.innerHTML = '';

            // First render the grid
            for (let y = 0; y < GRID_HEIGHT; y++) {
                for (let x = 0; x < GRID_WIDTH; x++) {
                    const cell = document.createElement('div');
                    cell.className = 'grid-cell';
                    
                    if (grid[y][x]) {
                        cell.classList.add('filled');
                        cell.textContent = grid[y][x].letter;
                        cell.style.backgroundColor = grid[y][x].color;
                    }
                    
                    gameGrid.appendChild(cell);
                }
            }

            // Then render the current block on top if it exists
            if (currentBlock) {
                const blockCell = gameGrid.children[currentBlock.y * GRID_WIDTH + currentBlock.x];
                blockCell.classList.add('filled');
                blockCell.textContent = currentBlock.letter;
                blockCell.style.backgroundColor = currentBlock.color;
            }
        }

        // Fix 3: Improved block movement with state management
        function moveBlock(dx, dy) {
            if (isPaused || isGameOver || !currentBlock || isMoving) return;

            const newX = currentBlock.x + dx;
            const newY = currentBlock.y + dy;

            if (!checkCollision(newX, newY)) {
                isMoving = true;
                currentBlock.x = newX;
                currentBlock.y = newY;
                updateGrid();
                isMoving = false;
            } else if (dy > 0) {
                placeBlock();
            }
        }

        // Fix 4: Improved drop function
        function dropBlock() {
            if (isPaused || isGameOver || !currentBlock || isMoving) return;
            
            isMoving = true;
            let newY = currentBlock.y;
            
            // Find the lowest position the block can go
            while (!checkCollision(currentBlock.x, newY + 1)) {
                newY++;
            }
            
            currentBlock.y = newY;
            updateGrid();
            placeBlock();
            isMoving = false;
        }
        function getWord(cells) {
            return cells.map(([x, y]) => grid[y][x].letter).join('');
        }

        // Fix: Improved word checking logic
        function checkForWords() {
            let foundMatch = false;
            
            // Check vertical matches
            for (let x = 0; x < GRID_WIDTH; x++) {
                for (let y = 0; y <= GRID_HEIGHT - TARGET_WORD.length; y++) {
                    const cells = Array.from(
                        { length: TARGET_WORD.length }, 
                        (_, i) => [x, y + i]
                    );
                    
                    if (cells.every(([cx, cy]) => grid[cy][cx])) {
                        const word = getWord(cells);
                        if (word === TARGET_WORD) {
                            clearCells(cells);
                            foundMatch = true;
                        }
                    }
                }
            }
            
            if (foundMatch) {
                shiftDownCells();
                return true;
            }
            return false;
        }

        // Fix: Improved cell clearing with animation support
        function clearCells(cells) {
            for (const [x, y] of cells) {
                const index = y * GRID_WIDTH + x;
                const cell = document.querySelector(`#game-grid .grid-cell:nth-child(${index + 1})`);
                if (cell) {
                    cell.style.transform = 'scale(0)';
                    setTimeout(() => {
                        grid[y][x] = null;
                        updateGrid();
                    }, 100);
                } else {
                    grid[y][x] = null;
                }
            }
        }

        // Fix: Improved gravity effect for falling blocks
        function shiftDownCells() {
            let moved;
            do {
                moved = false;
                for (let x = 0; x < GRID_WIDTH; x++) {
                    for (let y = GRID_HEIGHT - 2; y >= 0; y--) {
                        if (grid[y][x] && !grid[y + 1][x]) {
                            grid[y + 1][x] = grid[y][x];
                            grid[y][x] = null;
                            moved = true;
                        }
                    }
                }
                updateGrid();
            } while (moved);
        }

        // Fix: Improved block placement with state management
        function placeBlock() {
            if (!currentBlock) return;
            
            isMoving = true;
            
            // Place the current block
            grid[currentBlock.y][currentBlock.x] = {
                letter: currentBlock.letter,
                color: currentBlock.color
            };

            // Check for matches
            const hasMatches = checkForWords();
            
            // Set up next block
            currentBlock = nextBlock;
            nextBlock = createBlock();
            
            // Check for game over
            if (checkCollision(currentBlock.x, currentBlock.y)) {
                endGame();
                return;
            }
            
            updateGrid();
            isMoving = false;
        }

        function togglePause() {
            if (isGameOver) return;
            isPaused = !isPaused;
            document.querySelector('#pause-btn').textContent = isPaused ? 'RESUME' : 'PAUSE';
        }

        // Fix: Improved game over handling
        function endGame() {
            isGameOver = true;
            if (gameInterval) clearInterval(gameInterval);
            if (timerInterval) clearInterval(timerInterval);
            
            // Update best time if applicable
            if (!bestTime || gameTime < bestTime) {
                bestTime = gameTime;
                localStorage.setItem('bestTime', bestTime);
                document.querySelector('#best-time-container').innerHTML = 
                    `Best Time:<br>${formatTime(bestTime)}`;
            }
            
            const gameOverScreen = document.createElement('div');
            gameOverScreen.className = 'game-over';
            gameOverScreen.innerHTML = `
                <h2>Game Over!</h2>
                <p>Your time: ${formatTime(gameTime)}</p>
                ${bestTime ? `<p>Best time: ${formatTime(bestTime)}</p>` : ''}
                <input type="text" id="player-name" placeholder="Enter your name">
                <button onclick="submitScore()">Submit Score</button>
            `;
            
            document.getElementById('game-grid').appendChild(gameOverScreen);
        }
        // Make submitScore available globally
        window.submitScore = async function() {
            const nameInput = document.getElementById('player-name');
            const playerName = nameInput.value.trim();
            
            if (playerName) {
                await addLeaderboardEntry(playerName, gameTime);
                nameInput.disabled = true;
                document.querySelector('.game-over button').disabled = true;
            }
        };

        function setupLeaderboard() {
            if (!GAME_ID) return;

            try {
                const leaderboardRef = collection(db, 'daily_games', GAME_ID, 'leaderboard');
                const leaderboardQuery = query(leaderboardRef, orderBy('time'), limit(10));

                const unsubscribe = onSnapshot(leaderboardQuery, {
                    next: (snapshot) => {
                        const tbody = document.querySelector('#leaderboard tbody');
                        tbody.innerHTML = '';
                        
                        snapshot.docs.forEach((doc, index) => {
                            try {
                                const data = doc.data();
                                const row = tbody.insertRow();
                                row.insertCell().textContent = index + 1;
                                row.insertCell().textContent = String(data.name || 'Anonymous');
                                row.insertCell().textContent = formatTime(Number(data.time || 0));
                            } catch (err) {
                                console.error('Error processing leaderboard entry:', err);
                            }
                        });
                    },
                    error: (error) => {
                        console.error('Leaderboard listener error:', error);
                    }
                });

                window.leaderboardUnsubscribe = unsubscribe;
            } catch (error) {
                console.error('Error setting up leaderboard:', error);
            }
        }

        // Fix: Improved game initialization
        async function startGame() {
            // Reset game state
            grid = Array(GRID_HEIGHT).fill().map(() => Array(GRID_WIDTH).fill(null));
            gameTime = 0;
            isPaused = false;
            isGameOver = false;
            isMoving = false;
            
            // Initialize target word if not already done
            if (!TARGET_WORD) {
                const success = await initializeTargetWord();
                if (!success) {
                    console.error("Failed to initialize target word");
                    return;
                }
            }

            // Initialize blocks
            currentBlock = createBlock();
            nextBlock = createBlock();
            
            // Clear and setup intervals
            if (gameInterval) clearInterval(gameInterval);
            if (timerInterval) clearInterval(timerInterval);
            
            gameInterval = setInterval(() => {
                if (!isPaused && !isGameOver) {
                    moveBlock(0, 1);
                }
            }, 1000);

            timerInterval = setInterval(updateTimer, 1000);
            
            // Clean up previous leaderboard listener
            if (window.leaderboardUnsubscribe) {
                window.leaderboardUnsubscribe();
                window.leaderboardUnsubscribe = null;
            }
            
            // Initialize UI
            updateGrid();
            setupLeaderboard();
            
            // Reset timer display
            document.querySelector('#timer-container').innerHTML = 'Time:<br>00:00';
            document.querySelector('#pause-btn').textContent = 'PAUSE';
        }

        // Initialize event listeners
        function setupEventListeners() {
            document.getElementById('start-btn')?.addEventListener('click', startGame);
            document.getElementById('pause-btn')?.addEventListener('click', togglePause);
            document.getElementById('left-btn')?.addEventListener('click', () => moveBlock(-1, 0));
            document.getElementById('right-btn')?.addEventListener('click', () => moveBlock(1, 0));
            document.getElementById('down-btn')?.addEventListener('click', dropBlock);

            // Keyboard controls
            document.addEventListener('keydown', (e) => {
                if (e.key === 'ArrowLeft') moveBlock(-1, 0);
                if (e.key === 'ArrowRight') moveBlock(1, 0);
                if (e.key === 'ArrowDown') dropBlock();
                if (e.key === ' ') togglePause();
            });
        }

        // Initialize the game
        function initializeGame() {
            setupEventListeners();
            if (bestTime) {
                document.querySelector('#best-time-container').innerHTML = 
                    `Best Time:<br>${formatTime(bestTime)}`;
            }
            initializeTargetWord().then(() => {
                updateGrid();
            });
        }

        // Make initialization functions available globally
        window.initializeGame = initializeGame;
        window.submitScore = submitScore;

        // Initialize on load
        window.addEventListener('load', initializeGame);
    </script>
</body>
</html>
