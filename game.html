<!DOCTYPE html>
<html lang="en">
<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0, user-scalable=no">
    <title>LEXIMAX</title>
    <style>
        * {
            -webkit-tap-highlight-color: transparent;
            box-sizing: border-box;
            margin: 0;
            padding: 0;
            font-family: Arial, sans-serif;
        }
        body {
            background-color: #f0f0f0;
            display: flex;
            flex-direction: column;
            align-items: center;
            justify-content: center;
            min-height: 100vh;
            margin: 0;
            padding: 20px;
        }
        .game-wrapper {
            background-color: white;
            border-radius: 10px;
            box-shadow: 0 4px 6px rgba(0,0,0,0.1);
            padding: 20px;
            width: 100%;
            max-width: 500px;
        }
        #leximax-title {
            display: flex;
            justify-content: center;
            margin-bottom: 20px;
        }
        .title-block {
            width: 40px;
            height: 40px;
            display: flex;
            align-items: center;
            justify-content: center;
            margin: 0 2px;
            color: white;
            font-weight: bold;
            font-size: 38px;
        }
        #target-word-container {
            text-align: center;
            margin: 20px 0;
        }
        #target-word-label {
            font-size: 22px;
            font-weight: bold;
            margin-bottom: 9px;
            color: #333333;
        }
        #target-word {
            display: flex;
            justify-content: center;
            gap: 2px;
        }
        .target-letter {
            width: 40px;
            height: 40px;
            background-color: #004d40;
            color: white;
            display: flex;
            align-items: center;
            justify-content: center;
            font-weight: bold;
            font-size: 20px;
        }
        #game-grid {
            display: grid;
            grid-template-columns: repeat(8, 1fr);
            gap: 2px;
            background-color: #FFD700;
            border: 2px solid #003830;
            aspect-ratio: 1;
            margin: 20px 0;
            padding: 2px;
        }
        .grid-cell {
            aspect-ratio: 1;
            background-color: #004d40;
            display: flex;
            align-items: center;
            justify-content: center;
            font-weight: bold;
            color: white;
            font-size: 18px;
        }
        .grid-cell.filled {
            color: white;
            transition: transform 0.15s ease-in-out, opacity 0.15s ease-in-out;
        }
        .grid-cell.pop {
            transform: scale(1.2);
            opacity: 0;
        }
		#controls {
            display: flex;
            flex-direction: column;
            align-items: center;
            margin-top: 20px;
        }
        #mobile-controls {
            display: flex;
            justify-content: center;
            gap: 40px;
            margin-bottom: 20px;
        }
        .mobile-btn {
            width: 100px;
            height: 100px;
            background-color: #002147;
            color: white;
            border: none;
            border-radius: 8px;
            font-size: 45px;
            cursor: pointer;
            transition: background-color 0.2s;
        }
        .mobile-btn:hover {
            background-color: #003166;
        }
        #game-buttons {
            display: flex;
            justify-content: center;
            gap: 10px;
            margin-bottom: 15px;
        }
        .game-btn {
            width: 140px;
            padding: 16px;
            font-size: 18px;
            background-color: #002147;
            color: white;
            border: none;
            border-radius: 8px;
            font-weight: bold;
            cursor: pointer;
            transition: background-color 0.2s;
        }
        .game-btn:hover {
            background-color: #003166;
        }
        #time-display {
            display: flex;
            justify-content: space-between;
            align-items: center;
            gap: 20px;
            margin-top: 10px;
        }
        .time-container,
        .score-container {
            display: flex;
            align-items: center;
            justify-content: center;
            padding: 16px;
            font-size: 18px;
            min-width: 140px;
            background-color: #900C3F;
            color: white;
            border-radius: 8px;
            font-weight: bold;
            gap: 8px;
        }
        #leaderboard {
            margin-top: 20px;
            width: 100%;
            max-width: 500px;
            border-collapse: collapse;
            background-color: white;
            border-radius: 8px;
            overflow: hidden;
        }
        #leaderboard caption {
            font-weight: bold;
            margin-bottom: 10px;
            color: #333;
        }
        #leaderboard th, #leaderboard td {
            border: 1px solid #ddd;
            padding: 12px;
            text-align: left;
        }
        #leaderboard th {
            background-color: #002147;
            color: white;
        }
        #leaderboard tr:nth-child(even) {
            background-color: #f8f8f8;
        }
    </style>
</head>
<body>
    <div class="game-wrapper">
        <div id="leximax-title">
            <div class="title-block" style="background-color: #2196f3;">L</div>
            <div class="title-block" style="background-color: #f44336;">E</div>
            <div class="title-block" style="background-color: #4caf50;">X</div>
            <div class="title-block" style="background-color: #ffc107;">I</div>
            <div class="title-block" style="background-color: #9c27b0;">M</div>
            <div class="title-block" style="background-color: #0066FF;">A</div>
            <div class="title-block" style="background-color: #900C3F;">X</div>
        </div>

        <div id="target-word-container">
            <div id="target-word-label">TARGET WORD:</div>
            <div id="target-word">
                <div class="target-letter">G</div>
                <div class="target-letter">R</div>
                <div class="target-letter">A</div>
                <div class="target-letter">N</div>
                <div class="target-letter">D</div>
                <div class="target-letter">E</div>
                <div class="target-letter">U</div>
                <div class="target-letter">R</div>
            </div>
        </div>

        <div id="game-grid"></div>

        <div id="controls">
            <div id="mobile-controls">
                <button class="mobile-btn" id="left-btn">◀</button>
                <button class="mobile-btn" id="down-btn">▼</button>
                <button class="mobile-btn" id="right-btn">▶</button>
            </div>

            <div id="game-buttons">
                <button class="game-btn" id="start-btn">START</button>
                <button class="game-btn" id="pause-btn">PAUSE</button>
            </div>

            <div id="time-display">
                <div id="timer-container" class="time-container">
                    Time: <span>00:00</span>
                </div>
                <div id="score-container" class="score-container">
                    Score: <span>0</span>
                </div>
            </div>
        </div>
    </div>

    <table id="leaderboard">
        <caption>LEADERBOARD</caption>
        <thead>
            <tr>
                <th>Rank</th>
                <th>Name</th>
                <th>Score</th>
            </tr>
        </thead>
        <tbody></tbody>
    </table>
	<script>
        document.addEventListener('DOMContentLoaded', async () => {
            // Game constants
            const GRID_WIDTH = 8;
            const GRID_HEIGHT = 10;
            const COLORS = ['#2196f3', '#f44336', '#4caf50', '#ffc107', '#9c27b0', '#003366', '#009688'];
            const LETTERS = 'BCDFGHJKLMNPQRSTVWXZ';
            const VOWELS = 'AEIOUY';
            const TARGET_WORD = 'GRANDEUR';
			const GAME_ID = 'Game2024-01-01';

            // Game state variables
            let grid = [];
            let currentBlock = null;
            let nextBlock = null;
            let gameInterval = null;
            let gameTime = 0;
            let isPaused = false;
            let isGameOver = false;
            let isMoving = false;
            let currentScore = 0;
            let chainCount = 0;

            // Utility function for debouncing
            const debounce = (fn, delay) => {
                let timeoutId;
                return (...args) => {
                    if (timeoutId) clearTimeout(timeoutId);
                    timeoutId = setTimeout(() => fn.apply(null, args), delay);
                };
            };

            // Display utility functions
            function formatTime(seconds) {
                if (!seconds && seconds !== 0) return '--:--';
                const minutes = Math.floor(seconds / 60);
                const remainingSeconds = seconds % 60;
                return `${minutes.toString().padStart(2, '0')}:${remainingSeconds.toString().padStart(2, '0')}`;
            }

            function initializeDisplays() {
                const timerSpan = document.querySelector('#timer-container span');
                const scoreSpan = document.querySelector('#score-container span');
                if (timerSpan) timerSpan.textContent = '00:00';
                if (scoreSpan) scoreSpan.textContent = '0';
            }

            function updateTimer() {
                if (!isPaused && !isGameOver) {
                    try {
                        gameTime++;
                        const timerSpan = document.querySelector('#timer-container span');
                        if (timerSpan) {
                            timerSpan.textContent = formatTime(gameTime);
                        }
                    } catch (error) {
                        console.error('Error updating timer:', error);
                    }
                }
            }

            function updateScore(points) {
                try {
                    currentScore += points;
                    const scoreSpan = document.querySelector('#score-container span');
                    if (scoreSpan) {
                        scoreSpan.textContent = currentScore.toLocaleString();
                    }
                } catch (error) {
                    console.error('Error updating score:', error);
                }
            }

            // Grid initialization and block management
            function initGrid() {
                const gameGrid = document.getElementById('game-grid');
                gameGrid.innerHTML = '';
                grid = Array(GRID_HEIGHT).fill().map(() => Array(GRID_WIDTH).fill(null));
                
                for (let y = 0; y < GRID_HEIGHT; y++) {
                    for (let x = 0; x < GRID_WIDTH; x++) {
                        const cell = document.createElement('div');
                        cell.className = 'grid-cell';
                        cell.setAttribute('data-x', x);
                        cell.setAttribute('data-y', y);
                        gameGrid.appendChild(cell);
                    }
                }
            }

            function createBlock() {
                const color = COLORS[Math.floor(Math.random() * COLORS.length)];
                const letter = Math.random() < 0.3 ? 
                    VOWELS[Math.floor(Math.random() * VOWELS.length)] :
                    LETTERS[Math.floor(Math.random() * LETTERS.length)];
                return { color, letter, x: Math.floor(GRID_WIDTH / 2), y: 0 };
            }

            function drawBlock(block) {
                if (!block || block.x < 0 || block.x >= GRID_WIDTH || block.y < 0 || block.y >= GRID_HEIGHT) return;
                const cell = document.querySelector(`#game-grid .grid-cell[data-x="${block.x}"][data-y="${block.y}"]`);
                if (cell) {
                    cell.className = 'grid-cell filled';
                    cell.style.backgroundColor = block.color;
                    cell.textContent = block.letter;
                }
            }

            function clearBlock(block) {
                if (!block || block.x < 0 || block.x >= GRID_WIDTH || block.y < 0 || block.y >= GRID_HEIGHT) return;
                const cell = document.querySelector(`#game-grid .grid-cell[data-x="${block.x}"][data-y="${block.y}"]`);
                if (cell) {
                    cell.className = 'grid-cell';
                    cell.style.backgroundColor = '#004d40';
                    cell.textContent = '';
                }
            }
			function isCollision(block) {
                if (!block) return true;
                if (block.x < 0 || block.x >= GRID_WIDTH) return true;
                if (block.y >= GRID_HEIGHT) return true;
                if (block.y >= 0 && grid[block.y][block.x] !== null) return true;
                return false;
            }

            async function moveBlock(dx, dy) {
                if (!currentBlock || isPaused || isGameOver || isMoving) return;
                
                isMoving = true;
                clearBlock(currentBlock);
                
                const newX = currentBlock.x + dx;
                const newY = currentBlock.y + dy;
                const testBlock = { ...currentBlock, x: newX, y: newY };
                
                if (!isCollision(testBlock)) {
                    currentBlock.x = newX;
                    currentBlock.y = newY;
                    await new Promise(resolve => setTimeout(resolve, 0));
                    drawBlock(currentBlock);
                } else if (dy > 0) {
                    drawBlock(currentBlock);
                    placeBlock();
                } else {
                    drawBlock(currentBlock);
                }
                
                isMoving = false;
            }

            function dropBlock() {
                if (!currentBlock || isPaused || isGameOver) return;
                clearBlock(currentBlock);
                while (currentBlock.y < GRID_HEIGHT - 1 && !isCollision({ ...currentBlock, y: currentBlock.y + 1 })) {
                    currentBlock.y++;
                }
                placeBlock();
            }

            async function placeBlock() {
                if (!currentBlock || currentBlock.y < 0) return;
                grid[currentBlock.y][currentBlock.x] = { ...currentBlock };
                drawBlock(currentBlock);
                await checkMatches();
                checkGameOver();
                checkWin();
                currentBlock = nextBlock;
                nextBlock = createBlock();
                if (currentBlock) drawBlock(currentBlock);
            }

            function isPartOfTargetWord(letter) {
                return TARGET_WORD.includes(letter);
            }

            function checkNeighborsWithScoring(x, y, toRemove) {
                const current = grid[y][x];
                if (!current) return 0;
                
                let points = 0;
                const directions = [[0, 1], [1, 0], [0, -1], [-1, 0]];
                
                directions.forEach(([dx, dy]) => {
                    const nx = x + dx;
                    const ny = y + dy;
                    
                    if (nx >= 0 && nx < GRID_WIDTH && ny >= 0 && ny < GRID_HEIGHT) {
                        const neighbor = grid[ny][nx];
                        if (neighbor && !isPartOfTargetWord(current.letter) && !isPartOfTargetWord(neighbor.letter)) {
                            let matchPoints = 0;
                            if (current.letter === neighbor.letter) {
                                matchPoints += 150;
                            }
                            if (current.color === neighbor.color) {
                                matchPoints += 100;
                            }
                            if (current.letter === neighbor.letter && current.color === neighbor.color) {
                                matchPoints += 300;
                            }
                            
                            if (matchPoints > 0) {
                                points += matchPoints;
                                toRemove.add(`${x},${y}`);
                                toRemove.add(`${nx},${ny}`);
                            }
                        }
                    }
                });

                return points;
            }
			async function checkMatches() {
                const toRemove = new Set();
                let matchPoints = 0;
                
                for (let y = 0; y < GRID_HEIGHT; y++) {
                    for (let x = 0; x < GRID_WIDTH; x++) {
                        if (grid[y][x] && !isPartOfTargetWord(grid[y][x].letter)) {
                            const points = checkNeighborsWithScoring(x, y, toRemove);
                            matchPoints += points;
                        }
                    }
                }
                
                if (toRemove.size > 0) {
                    chainCount++;
                    const chainBonus = Math.pow(1.2, chainCount - 1);
                    const avgHeight = Array.from(toRemove)
                        .map(pos => parseInt(pos.split(',')[1]))
                        .reduce((a, b) => a + b, 0) / toRemove.size;
                    const heightMultiplier = avgHeight < GRID_HEIGHT / 3 ? 1 :
                                           avgHeight < (2 * GRID_HEIGHT) / 3 ? 1.5 : 2;
                    const timeMultiplier = Math.max(0.5, 1 - (Math.floor(gameTime / 30) * 0.1));
                    const finalPoints = Math.round(matchPoints * chainBonus * heightMultiplier * timeMultiplier);
                    
                    updateScore(finalPoints);
                    
                    // Batch DOM updates
                    const cells = Array.from(toRemove).map(pos => {
                        const [x, y] = pos.split(',').map(Number);
                        return document.querySelector(`#game-grid .grid-cell[data-x="${x}"][data-y="${y}"]`);
                    }).filter(cell => cell !== null);

                    // Add pop animation class to all cells simultaneously
                    cells.forEach(cell => cell.classList.add('pop'));

                    // Wait for animations to complete
                    await new Promise(resolve => setTimeout(resolve, 150));

                    // Remove blocks and update grid
                    toRemove.forEach(pos => {
                        const [x, y] = pos.split(',').map(Number);
                        grid[y][x] = null;
                        const cell = document.querySelector(`#game-grid .grid-cell[data-x="${x}"][data-y="${y}"]`);
                        if (cell) {
                            cell.className = 'grid-cell';
                            cell.style.backgroundColor = '#004d40';
                            cell.textContent = '';
                        }
                    });

                    dropColumns();
                } else {
                    chainCount = 0;
                }
            }

            function dropColumns() {
                for (let x = 0; x < GRID_WIDTH; x++) {
                    let writeY = GRID_HEIGHT - 1;
                    for (let y = GRID_HEIGHT - 1; y >= 0; y--) {
                        if (grid[y][x] !== null) {
                            if (y !== writeY) {
                                grid[writeY][x] = grid[y][x];
                                grid[y][x] = null;
                                clearBlock({ x, y });
                                drawBlock({ ...grid[writeY][x], x, y: writeY });
                            }
                            writeY--;
                        }
                    }
                }
            }

           async function checkWin() {
    // Check for horizontal matches (left-to-right AND right-to-left)
    for (let y = 0; y < GRID_HEIGHT; y++) {
        for (let x = 0; x < GRID_WIDTH; x++) {
            // Check left-to-right
            if (x <= GRID_WIDTH - TARGET_WORD.length) {
                let word = '';
                let isValid = true;
                let winningCells = [];
                
                for (let i = 0; i < TARGET_WORD.length; i++) {
                    if (!grid[y][x + i] || !grid[y][x + i].letter) {
                        isValid = false;
                        break;
                    }
                    word += grid[y][x + i].letter;
                    winningCells.push([x + i, y]);
                }
                
                if (isValid && word === TARGET_WORD) {
                    await handleWin(winningCells);
                    return;
                }
            }
            
            // Check right-to-left
            if (x >= TARGET_WORD.length - 1) {
                let word = '';
                let isValid = true;
                let winningCells = [];
                
                for (let i = 0; i < TARGET_WORD.length; i++) {
                    if (!grid[y][x - i] || !grid[y][x - i].letter) {
                        isValid = false;
                        break;
                    }
                    word += grid[y][x - i].letter;
                    winningCells.push([x - i, y]);
                }
                
                if (isValid && word === TARGET_WORD) {
                    await handleWin(winningCells);
                    return;
                }
            }
        }
    }
}

async function handleWin(winningCells) {
    isGameOver = true;
    clearInterval(gameInterval);
    
    // Highlight winning word with animation
    winningCells.forEach(([wx, wy]) => {
        const cell = document.querySelector(`#game-grid .grid-cell[data-x="${wx}"][data-y="${wy}"]`);
        if (cell) {
            cell.style.transform = 'scale(1.1)';
            cell.style.transition = 'transform 0.3s ease-out';
        }
    });
    
    // Wait for highlight animation
    await new Promise(resolve => setTimeout(resolve, 500));
    
    const timeStr = formatTime(gameTime);
    const message = `YOU DID IT IN ${timeStr}!`;
    
    endGame(message, true);
}
			function checkGameOver() {
                if (nextBlock && isCollision(nextBlock)) {
                    endGame('GAME OVER');
                }
            }

            function endGame(message, isWin = false) {
    isGameOver = true;
    clearInterval(gameInterval);
    
    const overlay = document.createElement('div');
    overlay.style.position = 'fixed';
    overlay.style.top = '50%';
    overlay.style.left = '50%';
    overlay.style.transform = 'translate(-50%, -50%)';
    overlay.style.backgroundColor = 'white';
    overlay.style.padding = '30px';
    overlay.style.borderRadius = '12px';
    overlay.style.boxShadow = '0 4px 20px rgba(0,0,0,0.15)';
    overlay.style.zIndex = '100';
    overlay.style.textAlign = 'center';
    overlay.style.maxWidth = '90%';
    overlay.style.width = '400px';

    if (isWin) {
        // Get current leaderboard data to determine rank
        const leaderboardTimes = Array.from(document.querySelectorAll('#leaderboard tbody tr td:last-child'))
            .map(td => {
                const [mins, secs] = td.textContent.split(':').map(Number);
                return mins * 60 + secs;
            })
            .sort((a, b) => a - b);
        
        const rankIndex = leaderboardTimes.findIndex(time => gameTime < time);
        const isTopTen = rankIndex !== -1 || leaderboardTimes.length < 10;
        const rankNumber = isTopTen ? rankIndex + 1 : null;
        
        // Convert rank number to word
        const rankWords = ["ONE", "TWO", "THREE", "FOUR", "FIVE", "SIX", "SEVEN", "EIGHT", "NINE", "TEN"];
        const rankWord = rankWords[rankIndex] || (leaderboardTimes.length < 10 ? rankWords[leaderboardTimes.length] : null);

        const timeStr = formatTime(gameTime);
        const messageContent = isTopTen 
            ? `WOW! Enter your name or nickname below to record your time of <b>${timeStr}</b> at number <b>${rankWord}</b> on the leaderboard for <b>${TARGET_WORD}</b>. Challenge your friends to beat your time by clicking on SHARE to copy this message on your clipboard.`
            : `GREAT! You built <b>${TARGET_WORD}</b> in <b>${timeStr}</b>. Challenge your friends to beat your time by clicking on SHARE to copy this message on your clipboard.`;

        const shareMessage = isTopTen
            ? `I am now number ${rankWord} on the leaderboard for ${TARGET_WORD} at https://playleximax.com/game.html?gameId=${GAME_ID} with a time of ${timeStr}. Can you beat me?`
            : `I built ${TARGET_WORD} at https://playleximax.com/game.html?gameId=${GAME_ID} in ${timeStr}. Can you beat me?`;

        overlay.innerHTML = `
            <div style="margin-bottom: 20px; font-size: 16px; line-height: 1.5;">
                ${messageContent}
            </div>
            ${isTopTen ? `
                <div style="margin-bottom: 20px;">
                    <input type="text" id="player-name" 
                           maxlength="12" 
                           placeholder="Enter your name"
                           style="width: 100%; padding: 10px; border: 2px solid #004d40; border-radius: 4px; font-size: 16px; margin-bottom: 10px;"
                    >
                </div>
            ` : ''}
            <button id="share-btn" style="
                width: 100%;
                padding: 12px;
                background-color: #003366;
                color: white;
                border: none;
                border-radius: 4px;
                font-weight: bold;
                font-size: 16px;
                cursor: pointer;
                transition: background-color 0.2s;
                margin-bottom: 15px;
            ">
                SHARE
            </button>
            <button id="close-overlay-btn" style="
                width: 100%;
                padding: 12px;
                background-color: #666;
                color: white;
                border: none;
                border-radius: 4px;
                font-weight: bold;
                font-size: 16px;
                cursor: pointer;
                transition: background-color 0.2s;
            ">
                CLOSE
            </button>
        `;

        document.body.appendChild(overlay);

        // After overlay is added to DOM, set up event listeners
        const shareBtn = document.getElementById('share-btn');
        if (shareBtn) {
            shareBtn.addEventListener('click', async () => {
                try {
                    await navigator.clipboard.writeText(shareMessage);
                    const originalText = shareBtn.textContent;
                    shareBtn.textContent = 'COPIED!';
                    shareBtn.style.backgroundColor = '#002244';
                    setTimeout(() => {
                        shareBtn.textContent = originalText;
                        shareBtn.style.backgroundColor = '#003366';
                    }, 2000);
                } catch (err) {
                    console.error('Failed to copy:', err);
                    shareBtn.textContent = 'COPY FAILED';
                    shareBtn.style.backgroundColor = '#d32f2f';
                }
            });
        }

        const closeBtn = document.getElementById('close-overlay-btn');
        if (closeBtn) {
            closeBtn.addEventListener('click', () => {
                overlay.remove();
            });
        }

        if (isTopTen) {
            const nameInput = document.getElementById('player-name');
            if (nameInput) {
                nameInput.focus();
                nameInput.addEventListener('keypress', async (e) => {
                    if (e.key === 'Enter') {
                        const name = nameInput.value.trim() || 'Anonymous';
                        try {
                            await window.firebaseOps.addLeaderboardEntry(GAME_ID, name, gameTime);
                            overlay.remove();
                        } catch (error) {
                            console.error('Error submitting score:', error);
                        }
                    }
                });
            }
        }
    } else {
        // Game Over message
        overlay.innerHTML = `
            <div style="margin-bottom: 20px; font-size: 18px; font-weight: bold;">
                ${message}
            </div>
            <button id="close-overlay-btn" style="
                width: 100%;
                padding: 12px;
                background-color: #666;
                color: white;
                border: none;
                border-radius: 4px;
                font-weight: bold;
                font-size: 16px;
                cursor: pointer;
                transition: background-color 0.2s;
            ">
                CLOSE
            </button>
        `;
        
        document.body.appendChild(overlay);
        
        const closeBtn = document.getElementById('close-overlay-btn');
        if (closeBtn) {
            closeBtn.addEventListener('click', () => {
                overlay.remove();
            });
        }
    }
}
            function startGame() {
                const overlay = document.querySelector('div[style*="position: fixed"]');
                if (overlay) overlay.remove();
                
                clearInterval(gameInterval);
                isGameOver = false;
                isPaused = false;
                gameTime = 0;
                currentScore = 0;
                chainCount = 0;
                
                initGrid();
                currentBlock = createBlock();
                nextBlock = createBlock();
                drawBlock(currentBlock);
                
                document.querySelector('#timer-container span').textContent = '00:00';
                document.querySelector('#score-container span').textContent = '0';
                pauseBtn.textContent = 'PAUSE';
                
                gameInterval = setInterval(() => {
                    if (!isPaused && !isGameOver) {
                        moveBlock(0, 1);
                        updateTimer();
                    }
                }, 1000);
            }
            function togglePause() {
                if (isGameOver) return;
                isPaused = !isPaused;
                pauseBtn.textContent = isPaused ? 'RESUME' : 'PAUSE';
            }

            // Event listeners
            const startBtn = document.getElementById('start-btn');
            const pauseBtn = document.getElementById('pause-btn');
            const leftBtn = document.getElementById('left-btn');
            const downBtn = document.getElementById('down-btn');
            const rightBtn = document.getElementById('right-btn');

            const debouncedMove = debounce((dx, dy) => moveBlock(dx, dy), 50);
            const debouncedDrop = debounce(() => dropBlock(), 50);

            startBtn.addEventListener('click', startGame);
            pauseBtn.addEventListener('click', togglePause);
            leftBtn.addEventListener('click', () => debouncedMove(-1, 0));
            rightBtn.addEventListener('click', () => debouncedMove(1, 0));
            downBtn.addEventListener('click', debouncedDrop);

            document.addEventListener('keydown', (e) => {
                if (e.repeat) return; // Prevent key repeat
                if (e.key === 'ArrowLeft') debouncedMove(-1, 0);
                if (e.key === 'ArrowRight') debouncedMove(1, 0);
                if (e.key === 'ArrowDown') debouncedMove(0, 1);
                if (e.key === ' ') {
                    e.preventDefault();
                    debouncedDrop();
                }
            });

            // Initialize the game
            initializeDisplays();
            initGrid();
        });
    </script>
</body>
</html>
